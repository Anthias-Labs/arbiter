//! Messengers/connections to the underlying EVM in the environment.
use std::{
    collections::HashMap,
    fmt::Debug,
    pin::Pin,
    sync::{Arc, Weak},
};

use futures_util::Stream;
use serde_json::value::RawValue;
use tokio::sync::broadcast::{Receiver as BroadcastReceiver, Sender as BroadcastSender};

use super::{cast::revm_logs_to_ethers_logs, *};
use crate::environment::{InstructionSender, OutcomeReceiver, OutcomeSender};

/// Represents a connection to the EVM contained in the corresponding
/// [`Environment`].
#[derive(Debug)]
pub struct Connection {
    /// Used to send calls and transactions to the [`Environment`] to be
    /// executed by `revm`.
    pub(crate) instruction_sender: Weak<InstructionSender>,

    /// Used to send results back to a client that made a call/transaction with
    /// the [`Environment`]. This [`ResultSender`] is passed along with a
    /// call/transaction so the [`Environment`] can reply back with the
    /// [`ExecutionResult`].
    pub(crate) outcome_sender: OutcomeSender,

    /// Used to receive the [`ExecutionResult`] from the [`Environment`] upon
    /// call/transact.
    pub(crate) outcome_receiver: OutcomeReceiver,

    pub(crate) event_sender: BroadcastSender<Broadcast>,

    /// A collection of `FilterReceiver`s that will receive outgoing logs
    /// generated by `revm` and output by the [`Environment`].
    pub(crate) filter_receivers: Arc<Mutex<HashMap<ethers::types::U256, FilterReceiver>>>,
}

impl From<&Environment> for Connection {
    fn from(environment: &Environment) -> Self {
        let instruction_sender = &Arc::clone(&environment.socket.instruction_sender);
        let (outcome_sender, outcome_receiver) = crossbeam_channel::unbounded();
        Self {
            instruction_sender: Arc::downgrade(instruction_sender),
            outcome_sender,
            outcome_receiver,
            event_sender: environment.socket.event_broadcaster.clone(),
            filter_receivers: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

#[async_trait::async_trait]
impl JsonRpcClient for Connection {
    type Error = ProviderError;

    /// Processes a JSON-RPC request and returns the response.
    /// Currently only handles the `eth_getFilterChanges` call since this is
    /// used for polling events emitted from the [`Environment`].
    async fn request<T: Serialize + Send + Sync, R: DeserializeOwned>(
        &self,
        method: &str,
        params: T,
    ) -> Result<R, ProviderError> {
        match method {
            "eth_getFilterChanges" => {
                // TODO: The extra json serialization/deserialization can probably be avoided
                // somehow

                trace!("Getting filter changes...");
                // Get the `Filter` ID from the params `T`
                // First convert it into a JSON `Value`
                let value = serde_json::to_value(&params)?;

                // Take this value as an array then cast it to a string
                let str = value.as_array().ok_or(ProviderError::CustomError(
                    "The params value passed to the `Connection` via a `request` was empty. 
                    This is likely due to not specifying a specific `Filter` ID!".to_string()
                ))?[0]
                    .as_str().ok_or(ProviderError::CustomError(
                        "The params value passed to the `Connection` via a `request` could not be later cast to `str`!".to_string()
                    ))?;

                // Now get the `U256` ID via the string decoded from hex radix.
                let id = ethers::types::U256::from_str_radix(str, 16)
                    .map_err(|e| ProviderError::CustomError(
                        format!("The `str` representation of the filter ID could not be cast into `U256` due to: {:?}!", 
                        e)))?;

                // Get the corresponding `filter_receiver` and await for logs to appear.
                let mut filter_receivers = self.filter_receivers.lock().unwrap();
                let filter_receiver =
                    filter_receivers
                        .get_mut(&id)
                        .ok_or(ProviderError::CustomError(
                            "The filter ID does not seem to match any that this client owns!"
                                .to_string(),
                        ))?;
                let mut logs = vec![];
                if let FilterType::Log(filter) = filter_receiver.filter.clone() {
                    let filtered_params = FilteredParams::new(Some(filter));
                    if let Some(receiver) = filter_receiver.receiver.as_mut() {
                        if let Ok(broadcast) = receiver.try_recv() {
                            match broadcast {
                                Broadcast::Event(received_logs) => {
                                    let ethers_logs = revm_logs_to_ethers_logs(received_logs);
                                    for log in ethers_logs {
                                        if filtered_params.filter_address(&log)
                                            && filtered_params.filter_topics(&log)
                                        {
                                            logs.push(log);
                                        }
                                    }
                                }
                                Broadcast::StopSignal => {
                                    return Err(ProviderError::CustomError(
                                        "The `EventBroadcaster` has stopped!".to_string(),
                                    ));
                                }
                                Broadcast::Block(_) => {
                                    // Do nothing
                                }
                            }
                        }
                    }
                }
                // Take the logs and Stringify then JSONify to cast into `R`.
                let logs_str = serde_json::to_string(&logs)?;
                let logs_deserializeowned: R = serde_json::from_str(&logs_str)?;
                Ok(logs_deserializeowned)
            }
            val => Err(ProviderError::CustomError(format!(
                "The method `{}` is not supported by the `Connection`!",
                val
            ))),
        }
    }
}

impl PubsubClient for Connection {
    type NotificationStream = Pin<Box<dyn Stream<Item = Box<RawValue>> + Send>>;

    fn subscribe<T: Into<ethers::types::U256>>(
        &self,
        id: T,
    ) -> Result<Self::NotificationStream, Self::Error> {
        let id = id.into();
        debug!("Subscribing to filter with ID: {:?}", id);

        let mut filter_receiver = self
            .filter_receivers
            .lock()
            .unwrap()
            .remove(&id)
            .take()
            .unwrap();

        let mut receiver = filter_receiver.receiver.take().unwrap();
        let stream = async_stream::stream! {
            let filter_type = filter_receiver.filter;
            match filter_type {
                    FilterType::Log(filter) => {while let Ok(broadcast) = receiver.recv().await {
                        match broadcast {
                            Broadcast::StopSignal => {
                                break;
                            }
                        Broadcast::Event(logs) => {
                            let filtered_params =
                                FilteredParams::new(Some(filter.clone()));
                            let ethers_logs = revm_logs_to_ethers_logs(logs);
                            // Return the first log that matches the filter, if any
                            for log in ethers_logs {
                                if filtered_params.filter_address(&log)
                                    && filtered_params.filter_topics(&log)
                                {
                                    let raw_log = match serde_json::to_string(&log) {
                                        Ok(log) => log,
                                        Err(e) => {
                                            eprintln!("Error serializing log: {}", e);
                                            continue;
                                        }
                                    };
                                    let raw_log = match RawValue::from_string(raw_log) {
                                        Ok(log) => log,
                                        Err(e) => {
                                            eprintln!("Error creating RawValue: {}", e);
                                            continue;
                                        }
                                    };
                                    yield raw_log;
                                }
                            }

                        },
                        Broadcast::Block(_) => { continue;}

                }}},
                FilterType::Block => {
                    while let Ok(broadcast) = receiver.recv().await{
                        match broadcast {
                            Broadcast::StopSignal => {
                                break;
                            }
                            Broadcast::Event(_) => { continue; }
                            Broadcast::Block(block) => {
                                let raw_block = match serde_json::to_string(&block) {
                                    Ok(block) => block,
                                    Err(e) => {
                                        eprintln!("Error serializing block: {}", e);
                                        continue;
                                    }
                                };
                                let raw_block = match RawValue::from_string(raw_block) {
                                    Ok(block) => block,
                                    Err(e) => {
                                        eprintln!("Error creating RawValue: {}", e);
                                        continue;
                                    }
                                };
                                yield raw_block;
                            }
                        }
                    }
                }
            }
        };

        Ok(Box::pin(stream))
    }

    // TODO: At the moment, this won't actually drop the stream.
    fn unsubscribe<T: Into<ethers::types::U256>>(&self, id: T) -> Result<(), Self::Error> {
        let id = id.into();
        debug!("Unsubscribing from filter with ID: {:?}", id);
        if self.filter_receivers.lock().unwrap().remove(&id).is_some() {
            Ok(())
        } else {
            Err(ProviderError::CustomError(
                "The filter ID does not seem to match any that this client owns!".to_string(),
            ))
        }
    }
}

/// Packages together a [`crossbeam_channel::Receiver<Vec<Log>>`] along with a
/// [`Filter`] for events. Allows the client to have a stream of filtered
/// events.
#[derive(Debug)]
pub(crate) struct FilterReceiver {
    /// The filter definition used for this receiver.
    /// Comes from the `ethers-rs` crate.
    pub(crate) filter: FilterType,

    /// The receiver for the channel that receives logs from the broadcaster.
    /// These are filtered upon reception.
    pub(crate) receiver: Option<BroadcastReceiver<Broadcast>>,
}

#[derive(Clone, Debug)]
pub(crate) enum FilterType {
    Block,
    Log(Filter),
}
